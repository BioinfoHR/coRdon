{
    "contents" : "library(Biostrings)\nlibrary(Biobase)\nlibrary(plyr)\nlibrary(stringr)\n\n# helper constants\n\nRPKOs = c(\"K02945\", \"K02967\", \"K02982\", \"K02986\", \"K02988\", \"K02990\", \"K02992\", \"K02994\", \"K02996\",\n          \"K02946\", \"K02948\" ,\"K02950\" ,\"K02952\" ,\"K02954\" ,\"K02956\" ,\"K02959\" ,\"K02961\" ,\"K02963\" ,\n          \"K02965\" , \"K02968\" , \"K02970\" , \"K02981\" , \"K02985\" , \"K02984\" , \"K02987\" , \"K02989\" , \"K02991\",\n          \"K02993\" , \"K02995\" , \"K02997\" , \"K02947\" , \"K02949\" , \"K02951\" , \"K02953\" , \"K02955\" , \"K02958\" ,\n          \"K02957\" , \"K02960\" , \"K02962\" , \"K02964\" , \"K02966\" , \"K02969\" , \"K02971\" , \"K02973\" , \"K02974\" , \"K02975\" ,\n          \"K02976\" , \"K02978\" , \"K02977\" , \"K02979\" , \"K02980\" , \"K02983\" , \"K02998\" , \"K02863\" , \"K02886\" ,\n          \"K02906\" , \"K02926\" , \"K02931\" , \"K02933\" , \"K02935\" , \"K02939\" , \"K02864\" , \"K02867\" , \"K02869\" ,\n          \"K02871\" , \"K02874\" , \"K02876\" , \"K02878\" , \"K02879\" , \"K02881\" , \"K02884\" , \"K02887\" , \"K02888\" ,\n          \"K02890\" , \"K02892\" , \"K02895\" , \"K02897\" , \"K02899\" , \"K02902\" , \"K02904\" , \"K02907\" , \"K02909\" ,\n          \"K02911\" , \"K02913\" , \"K02914\" , \"K02916\" , \"K02919\" , \"K07590\" , \"K02925\" , \"K02930\" , \"K02932\" ,\n          \"K02934\" , \"K02937\" , \"K02936\" , \"K02938\" , \"K02940\" , \"K02866\" , \"K02865\" , \"K02868\" , \"K02870\" ,\n          \"K02873\" , \"K02872\" , \"K02875\" , \"K02877\" , \"K02880\" , \"K02883\" , \"K02882\" , \"K02885\" , \"K02889\" ,\n          \"K02891\" , \"K02894\" , \"K02893\" , \"K02896\" , \"K02898\" , \"K02901\" , \"K02900\" , \"K02903\" , \"K02905\" ,\n          \"K02908\" , \"K02910\" , \"K02912\" , \"K02915\" , \"K02918\" , \"K02917\" , \"K02920\" , \"K02922\" , \"K02921\" ,\n          \"K02923\" , \"K02924\" , \"K02927\" , \"K02928\" , \"K02929\" , \"K02941\" , \"K02942\" , \"K02943\" , \"K02944\" ,\n          \"K01977\" , \"K01980\" , \"K01985\" , \"K01979\" , \"K01982\" , \"K01981\"\n)\n\n# constants\n\ndummy<-\"AAAAACAAGAATACAACCACGACTAGAAGCAGGAGTATAATCATGATTCAACACCAGCATCCACCCCCGCCTCGACGCCGGCGTCTACTCCTGCTTGAAGACGAGGATGCAGCCGCGGCTGGAGGCGGGGGTGTAGTCGTGGTTTAATACTAGTATTCATCCTCGTCTTGATGCTGGTGTTTATTCTTGTTT\"\n\ncodons<-strsplit(strbreak(dummy, width=3, exdent=0, collapse=\"|\"), split=\"\\\\|\")[[1]]\nstops<-c(\"TAA\", \"TAG\", \"TGA\")\nnostops<-codons[!(codons %in% stops)]\n\n\n\nctab<-data.frame(\n    codon=nostops,\n    aa=as.factor(as.character(translate(DNAStringSet(nostops)))),\n    codonstr=as.character(nostops), stringsAsFactors=F\n)\n\nacnt <- tapply(ctab$codon, ctab$aa, length)\nordaa <- ctab[order(ctab$aa),\"aa\"]\n\n# functions\n\ncnorm<-function(x) x/sum(x)\ncnormm <- function(x) if(is.matrix(x)) x/rowSums(x) else x/x\n\nrcm <- function(x) if(is.matrix(x)) as.integer(!is.nan(rowSums(x))) else as.integer(!is.nan(x))\nbyaa<-function(x) unlist(tapply(x,ctab$aa,cnorm))\n\nbyaas <- function(x) do.call(cbind, sapply(names(acnt), function(y) cnormm(x[,ctab$aa %in% y])))\nbyrcs <- function(x) sapply(names(acnt), function(y) rcm(x[,ordaa %in% y]))\n\n\n# optimized MILC calculator\n# the only required parameter is the codon usage table set,\n# and MILC will be calculated against the average CU of that set.\n# one optional parameter:\n# subsets - (named) list of\n#         - logical vectors of the same length as nrow(s), or\n#         - additional CU table set(s) that will be processed\n# the function returns a data frame of the same row length as nrow(s)\n# and ncol equal to the number of subsets plus one (self)\n\ncalcMilc<-function(s, subsets=list()) {\n\n    # test parameters\n    if (length(subsets)>1) if (all(!subsets)) warning(\"Subset is empty!\")\n    if(! inherits(s, \"codonTable\")) stop(\"First argument must be a codon usage table!\")\n    nseq <- nrow(s)\n\n    if(!is.list(subsets)) stop(paste(\"subsets must be a (named) list of logical vectors, each of length\", nseq,\n                                     \"or codonTable objects (of any length)\"))\n    if(length(subsets) != 0) {\n        ok <- sapply(subsets, function(x) {\n            all(is.vector(x, mode = \"logical\"), length(x) == nseq) |\n                all(inherits(x, \"codonTable\"), nrow(x) > 0)\n        })\n        stopifnot(ok)\n        nam <- names(subsets)\n        nsubs <- length(subsets)\n        if(is.null(nam)) {\n            nam <- paste(\"subset\", 1:nsubs, sep = \".\")\n        } else {\n            nam[nam == \"\"] <- paste(\"subset\", (1:nsubs)[nam == \"\"], sep = \".\")\n        }\n        names(subsets) <- make.names(nam, unique = TRUE)\n    }\n\n    # add a dummy self selection to subsets\n    self_set <- rep(TRUE, nseq)\n    subsets <- c(list(self = c(self_set)), subsets)\n\n    # strip all unneeded info and convert to matrix\n    o<-as.matrix(s[,nostops])\n\n    # preprocess all subsets\n    gc_list <- sapply(subsets, function(y) {\n        if(is.vector(y, mode = \"logical\")) {\n            sel <- o[y,] # this should never give error, because we tested for equal length\n        } else {\n            sel <- as.matrix(y[,nostops])\n        }\n        sel_sum <- colSums(sel) # add counts per codon\n        gc <- byaa(sel_sum) # and normalize synonymous codons to sum = 1\n        gc\n    }, simplify = FALSE)\n\n    # make fc values from original table\n    fc<-byaas(o)\n\n    # and correction factor\n    corr1 <- t(t(byrcs(fc)) * as.vector(acnt-1))\n    l <- s$len\n    cf <- rowSums(corr1)/l - 0.5\n\n    # now loop through all the gc's and calculate distance for each gene in the original set\n    milcs <- sapply(gc_list, function(gc) {\n\n        ma <- 2 * o[,order(ctab$aa)] * log(t(t(fc)/gc))\n        MILC <- rowSums(ma, na.rm = TRUE)/l - cf\n    })\n    if(sum(s$len==0)) {s[s$len==0,\"problem\"]<-TRUE\n    warning(\"Sequences of length 0 exist\")\n    }\n    return(cbind(s, milcs))\n}\n\n\nreadSet <- function(folder=., KOs=c(), zipped = FALSE){\n    aset <- readDNAStringSet(folder)\n    ctable <- oligonucleotideFrequency(aset, width = 3, step = 3)\n    ID <- names(aset)\n    KO <- str_extract(ID, \"K\\\\d{5}\")\n    COG <- str_extract(ID, \"([KCN]|TW)OG\\\\d{5}\")\n    len.stop <- rowSums(ctable[,codons])\n    len <- rowSums(ctable[,nostops])\n    problem <- rowSums(ctable) != len.stop\n\n    ccc = data.frame(\n        ID = ID,\n        ctable,\n        KO = KO,\n        COG = COG,\n        len.stop = len.stop,\n        len = len,\n        problem = problem\n    )\n\n    class(ccc) <- c(class(ccc), \"codonTable\")\n    ccc\n}\ncalculateMelp <- function(file,RPKOs){\n    myset <- readSet(file)\n    ribosomals <- myset$KO %in% RPKOs\n    milc <- calcMilc(myset, list(ribosomal = ribosomals))\n    milc$melp <- milc$self / milc$ribosomal\n    milc$name <- file\n    return(milc)\n}\nmelp_all <- function(path){\n    currwd <- getwd()\n    setwd(path)\n    sample <- list()\n    sample <- lapply(list.files(path),function(x){calculateMelp(x,RPKOs)})\n    all_files <- do.call(\"rbind\",sample)\n    setwd(currwd)\n    rm(sample)\n    all_files[!is.na(all_files$melp),]\n    return(all_files)\n}\npldensity<-function(a,groupnames){\n    #a is aggregated data.frame BY NAMES (H1,H2,...,L1,...)\n    a<-a[!is.na(a$x),]\n    l <- list()\n    y <- list()\n    for (i in 1:length(groupnames)){\n        l[[i]] <- grep(groupnames[i],a$Group.1)\n        if (length(l[[i]])) y[[i]] <- density(a$x[l[[i]]])\n        #lines(y,col=i)\n    }\n    x_lim <- range(sapply(y, function(x){ range(x$x)}))\n    y_lim <- range(sapply(y, function(x){ range(x$y)}))\n\n    plot(y[[1]],ylim=y_lim,xlim=x_lim,main = \"Density by groups\")\n    for (i in 2:length(y)){\n        lines(y[[i]],col=i)\n    }\n}\n\n\n#################################################################\n\n\n\n\nmin_length <- 30\npercentile_top <- 0.90\nperc <- c(0.95, 0.90, 0.85, 0.70, 0.50)\n#KEGG_maps_folder <- \"KEGG_maps\"\n#location_of_ko <- \"C:/Users/mfabijanic/Dropbox/Dusko/maja/ko.Robj\"\n#location_of_brite <- \"C:/Users/mfabijanic/Dropbox/Dusko/maja/brite.Robj\"\n# load KO and BRITE ontologies (use separate script to prepare)\n#load(location_of_ko)\n#load(location_of_brite)\n\nreduce.contable <- function(ctb, column = \"B\") {\n    values <- unique(ko[,column])\n    tt <- lapply(values, function(x){\n        KOs <- ko[ko[,column] == x, \"KO\", drop=TRUE]\n        KOs <- unique(KOs)\n        counts <- subset(ctb, KO %in% KOs , select = -KO)\n        colSums(counts, na.rm = TRUE)\n    })\n    contable <- do.call(rbind, tt)\n    rownames(contable) <- values\n    as.data.frame(contable)\n}\n\nmake.stats <- function(contable) {\n\n    rows <- names(contable)\n    top_rows <- rows[grep(\"top\", rows)]\n\n    all <- contable$all\n    all.sum <- sum(all)\n\n    by.top <- sapply(top_rows, function(row) {\n\n        top <- contable[,row]\n        top.sum <- sum(top)\n\n        ct <- data.frame(all = all, top)\n        names(ct) <- c(\"all\", \"cnt\")\n        rownames(ct) <- rownames(contable)\n        sc <- top.sum / all.sum\n        scaled_top <- top + 1\n        scaled_all <- all * sc + 1\n        ct$enrich <- (scaled_top - scaled_all) / scaled_all * 100\n        ct$M <- log2(scaled_top) - log2(scaled_all)\n        ct$A <- (log2(scaled_all) + log2(scaled_top)) / 2\n        pvals =\n            apply(ct[,c(\"all\", \"cnt\")], 1, function(x) {\n                b = binom.test(x[2], top.sum, x[1]/all.sum)\n                b$p.value\n            })\n        ct$pvals = pvals\n        ct$padj = p.adjust(pvals, method = \"BH\")\n        ct$all <- NULL\n        ct\n\n    }, simplify = FALSE)\n\n    bound <- do.call(cbind, by.top)\n    data.frame(all = all, bound)\n\n}\n\n\n\nmake.contable <- function(csm, KEGG) {\n    if (!KEGG) csm$KO <- as.factor(as.character(csm$ID))\n    all <- as.vector(table(csm$KO))\n    top <- sapply(perc, function(x) {\n        as.vector(table(csm[csm$melp >= quantile(csm$melp, x), \"KO\"]))\n    })\n    top <- as.data.frame(top)\n    names(top) <- make.names(paste(\"top\", perc, sep=\"_\"))\n\n    data.frame(all = all, top, row.names = levels(csm$KO), KO = levels(csm$KO))\n}\ndoall_csm <- function(csm,levels_KEGG=c()){\n    csm <- csm[csm$len > min_length,]\n    enrichment <-list()\n    KEGG <- T\n    if (all(is.na(csm$KO))) KEGG <- F\n    if(KEGG)\n        if(!(exists(\"ko\")&&exists(\"brite\"))) {\n            KEGG <- F\n            print(\"ko.Robj and brite.Robj not found\")\n        }\n    csm$KO <- csm$ID\n    # three levels of ontology exist: B (very broad), C (pathways), and KO (orthology)\n    # we'll summarize by each level separately\n\n    # make a contingency table for KO level, this is the base for other two\n    contable_ko <- make.contable(csm, KEGG)\n    name <- unique(csm$name)\n\n    if (KEGG){\n\n        csm$KO <- as.factor(csm$KO)\n\n        if (\"B\" %in% levels_KEGG){\n            contable_b <- reduce.contable(contable_ko, \"B\")\n            contable_b <- make.stats(contable_b)\n            contable_b$B <- rownames(contable_b)\n            #    write.table(contable_b, file=paste(st,\"contable_b.txt\", sep=\"_\"), row.names = FALSE, sep = \"\\t\")\n            enrichment[[name]][[\"B\"]] <- contable_b\n            print(paste(\"Enrichment calculated for level B for name \",name,sep=\"\"))\n        }\n        if (\"C\" %in% levels_KEGG){\n\n            contable_c <- reduce.contable(contable_ko, \"C\")\n            contable_c <- make.stats(contable_c)\n            contable_c$C <- rownames(contable_c)\n            contable_cc <- merge(contable_c, brite, by.x=\"C\", by.y=\"C\", all.x=TRUE)\n            contable_cc$name <- name\n            #    contable_cc <- contable_cc[order(contable_cc$padj),]\n            #    write.table(contable_cc, file=paste(st,\"contable_c.txt\", sep=\"_\"), row.names = FALSE, sep = \"\\t\")\n            enrichment[[name]][[\"C\"]] <- contable_cc\n            print(paste(\"Enrichment calculated for level C for name \",name,sep=\"\"))\n        }\n    }\n    contable_koc <- make.stats(contable_ko)\n    contable_koc$KO <- rownames(contable_koc)\n    if (KEGG){\n        contable_kocc <- merge(contable_koc, unique(ko[,c(\"KO\", \"desc\")]), by.x=\"KO\", by.y=\"KO\", all.x=TRUE)\n        kos <- unique(csm$KO)\n    }else{\n        contable_kocc <- contable_koc\n        kos <- unique(csm$ID)\n    }\n    contable_kocc$median <- 0\n    if (!KEGG)\n    {\n        contable_kocc$desc <- name\n        contable_kocc$name <- name\n        for (i in 1:length(kos))\n            contable_kocc[contable_kocc$KO==kos[i],\"median\"] <- median(csm[csm$ID==kos[i],\"melp\"])\n    }\n    if (KEGG)\n    {\n        contable_kocc$name <- name\n        medianis2 <- aggregate.data.frame(csm$melp,by=list(csm$KO),FUN=median)\n        contable_kocc$median <- 0\n        for(i in medianis2$Group.1)\n        {\n            contable_kocc[contable_kocc$KO==i,]$median <- medianis2[medianis2$Group.1==i,]$x\n        }\n    }\n    enrichment[[name]][[\"KO\"]] <- contable_kocc\n    #    contable_kocc <- contable_kocc[order(contable_kocc$padj),]\n    #    write.table(contable_kocc, file=paste(st,\"contable_ko.txt\", sep=\"_\"), row.names = FALSE, sep = \"\\t\")\n    if(KEGG) enrichment[[name]][[\"KO\"]]<-enrichment[[name]][[\"KO\"]][,c(2:32,1,33:35)]\n    enrichment[[name]][[\"KO\"]] <- enrichment[[name]][[\"KO\"]][!is.na(enrichment[[name]][[\"KO\"]]$median),]\n    enrichment[[name]][[\"KO\"]] <- enrichment[[name]][[\"KO\"]][!duplicated(enrichment[[name]][[\"KO\"]]$KO),]\n    if (\"C\"%in% levels_KEGG)\n    {\n        #enrichment[[name]][[\"C\"]] <- enrichment[[name]][[\"C\"]][!is.na(enrichment[[name]][[\"C\"]]$median),]\n        enrichment[[name]][[\"C\"]] <- enrichment[[name]][[\"C\"]][!duplicated(enrichment[[name]][[\"C\"]]$C),]\n        enrichment[[name]][[\"C\"]]$name <- name\n    }\n    if (\"B\"%in% levels_KEGG) {\n        #enrichment[[name]][[\"B\"]] <- enrichment[[name]][[\"B\"]][!is.na(enrichment[[name]][[\"B\"]]$median),]\n        enrichment[[name]][[\"B\"]] <- enrichment[[name]][[\"B\"]][!duplicated(enrichment[[name]][[\"B\"]]$B),]\n        enrichment[[name]][[\"B\"]]$name <- name\n\n    }\n    return(enrichment[[name]])\n}\n",
    "created" : 1437477290377.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2883814601",
    "id" : "13364CE7",
    "lastKnownWriteTime" : 1437477401,
    "path" : "~/GitHub_BioinfoHR/coRdon/R/hello.R",
    "project_path" : "R/hello.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}